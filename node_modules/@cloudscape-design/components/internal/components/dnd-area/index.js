// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useEffect, useRef } from 'react';
import { DndContext, DragOverlay } from '@dnd-kit/core';
import { arrayMove, SortableContext, useSortable, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import clsx from 'clsx';
import { joinStrings } from '../../utils/strings';
import Portal from '../portal';
import useDragAndDropReorder from './use-drag-and-drop-reorder';
import useLiveAnnouncements from './use-live-announcements';
import styles from './styles.css.js';
export function DndArea({ items, renderItem, onItemsChange, disableReorder, i18nStrings, borderRadiusVariant = 'item', }) {
    var _a;
    const { activeItemId, setActiveItemId, collisionDetection, handleKeyDown, sensors } = useDragAndDropReorder({
        items,
    });
    const activeItem = activeItemId ? items.find(item => item.id === activeItemId) : null;
    const isDragging = activeItemId !== null;
    const announcements = useLiveAnnouncements(Object.assign({ items, isDragging }, i18nStrings));
    const portalContainer = usePortalContainer();
    return (React.createElement(DndContext, { sensors: sensors, collisionDetection: collisionDetection, accessibility: {
            announcements,
            restoreFocus: false,
            screenReaderInstructions: i18nStrings.dragHandleAriaDescription
                ? { draggable: i18nStrings.dragHandleAriaDescription }
                : undefined,
            container: portalContainer,
        }, onDragStart: ({ active }) => setActiveItemId(active.id), onDragEnd: event => {
            setActiveItemId(null);
            const { active, over } = event;
            if (over && active.id !== over.id) {
                const oldIndex = items.findIndex(item => item.id === active.id);
                const newIndex = items.findIndex(item => item.id === over.id);
                onItemsChange(arrayMove([...items], oldIndex, newIndex));
            }
        }, onDragCancel: () => setActiveItemId(null) },
        React.createElement(SortableContext, { disabled: disableReorder, items: items.map(item => item.id), strategy: verticalListSortingStrategy }, items.map(item => (React.createElement(DraggableItem, { key: item.id, item: item, renderItem: renderItem, onKeyDown: handleKeyDown, dragHandleAriaLabel: i18nStrings.dragHandleAriaLabel, borderRadiusVariant: borderRadiusVariant })))),
        React.createElement(Portal, { container: portalContainer },
            React.createElement(DragOverlay, { className: clsx(styles['drag-overlay'], styles[`drag-overlay-${borderRadiusVariant}`]), dropAnimation: null, style: { zIndex: 5000 } }, activeItem &&
                renderItem({
                    item: activeItem,
                    style: {},
                    className: styles.active,
                    isDragging: true,
                    isSorting: false,
                    isActive: true,
                    dragHandleProps: {
                        ariaLabel: (_a = joinStrings(i18nStrings.dragHandleAriaLabel, activeItem.label)) !== null && _a !== void 0 ? _a : '',
                        onKeyDown: handleKeyDown,
                    },
                })))));
}
function usePortalContainer() {
    const portalContainerRef = useRef(document.createElement('div'));
    useEffect(() => {
        const container = portalContainerRef.current;
        if (!container.isConnected) {
            document.body.appendChild(container);
        }
        return () => {
            if (container.isConnected) {
                document.body.removeChild(container);
            }
        };
    }, []);
    return portalContainerRef.current;
}
function DraggableItem({ item, dragHandleAriaLabel, onKeyDown, renderItem, borderRadiusVariant, }) {
    var _a;
    const { isDragging, isSorting, listeners, setNodeRef, transform, attributes } = useSortable({ id: item.id });
    const style = { transform: CSS.Translate.toString(transform) };
    const dragHandleListeners = attributes['aria-disabled']
        ? {}
        : Object.assign(Object.assign({}, listeners), { onKeyDown: (event) => {
                if (onKeyDown) {
                    onKeyDown(event);
                }
                if (listeners === null || listeners === void 0 ? void 0 : listeners.onKeyDown) {
                    listeners.onKeyDown(event);
                }
            } });
    const className = clsx(isDragging && clsx(styles.placeholder, styles[`placeholder-${borderRadiusVariant}`]), isSorting && styles.sorting);
    return (React.createElement(React.Fragment, null, renderItem({
        item,
        ref: setNodeRef,
        style,
        className,
        isDragging,
        isSorting,
        isActive: false,
        dragHandleProps: Object.assign(Object.assign({}, dragHandleListeners), { ariaLabel: (_a = joinStrings(dragHandleAriaLabel, item.label)) !== null && _a !== void 0 ? _a : '', ariaDescribedby: attributes['aria-describedby'], disabled: attributes['aria-disabled'] }),
    })));
}
//# sourceMappingURL=index.js.map